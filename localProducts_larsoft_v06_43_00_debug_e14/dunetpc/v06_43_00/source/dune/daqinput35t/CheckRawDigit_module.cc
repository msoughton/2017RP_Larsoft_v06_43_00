////////////////////////////////////////////////////////////////////////
// Class:       CheckRawDigit
// Module Type: analyzer
// File:        CheckRawDigit_module.cc
//
// Generated at Wed Jun  1 11:04:07 2016 by Tingjun Yang using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "TH1D.h"
#include "lbne-raw-data/Services/ChannelMap/ChannelMapService.h"
#include "art/Framework/Services/Optional/TFileService.h" 
#include "lardataobj/RawData/RawDigit.h"

namespace dune {
  class CheckRawDigit;
}

class dune::CheckRawDigit : public art::EDAnalyzer {
public:
  explicit CheckRawDigit(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CheckRawDigit(CheckRawDigit const &) = delete;
  CheckRawDigit(CheckRawDigit &&) = delete;
  CheckRawDigit & operator = (CheckRawDigit const &) = delete;
  CheckRawDigit & operator = (CheckRawDigit &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;

private:

  // Declare member data here.
  std::string fRawDigitModuleLabel, fRawDigitModuleInstance;
  TH1D *sig[3][32][28];
  art::ServiceHandle<lbne::ChannelMapService> fChannelMap;

 
};


dune::CheckRawDigit::CheckRawDigit(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  fRawDigitModuleLabel = p.get<std::string>("RawDigitModuleLabel");
  fRawDigitModuleInstance = p.get<std::string>("RawDigitModuleInstance");
}

void dune::CheckRawDigit::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  art::Handle<std::vector<raw::RawDigit> > rawDigitHandle;
  e.getByLabel(fRawDigitModuleLabel, fRawDigitModuleInstance, rawDigitHandle);
  std::vector<raw::RawDigit> const& rawDigitVector(*rawDigitHandle);
  //const unsigned int n_channels = fGeom->Nchannels();

  int count[3][32];
  for (int i = 0; i<3; ++i){
    for (int j = 0; j<32; ++j){
      count[i][j] = 0;
    }
  }
  for (std::vector<raw::RawDigit>::const_iterator digitIt = rawDigitVector.begin(); digitIt != rawDigitVector.end(); ++digitIt) {
    unsigned int ch = digitIt->Channel(); //offline
    unsigned int plane     = fChannelMap->PlaneFromOfflineChannel(ch);
    unsigned int rce       = fChannelMap->RCEFromOfflineChannel(ch);
    unsigned int regulator = fChannelMap->RegulatorFromOfflineChannel(ch);
    float ped = digitIt->GetPedestal();
    for (unsigned s = 0; s< 15000; ++s){
      sig[plane][rce*2+regulator][count[plane][rce*2+regulator]]->SetBinContent(s+1,digitIt->ADC(s)-ped);
    }
    ++count[plane][rce*2+regulator];
  }
}

void dune::CheckRawDigit::beginJob()
{
  // Implementation of optional member function here.
  art::ServiceHandle<art::TFileService> tfs;
  for (int i = 0; i<3; ++i){
    for (int j = 0; j<32; ++j){
      for (int k = 0; k<28; ++k){
        sig[i][j][k] = tfs->make<TH1D>(Form("sig_%d_%d_%d",i,j,k),Form("Plane=%d Regulator=%d Channel=%d",i,j,k),15000,0,15000);
      }
    }
  }
}

DEFINE_ART_MODULE(dune::CheckRawDigit)
